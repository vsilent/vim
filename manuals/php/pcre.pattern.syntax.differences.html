<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <title>Отличия от Perl</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
 </head>
 <body><div style="text-align: center;">
 <div class="prev" style="float: left;"><a href="reference.pcre.pattern.syntax.html">Описание синтаксиса Perl-совместимых регулярных выражений</a></div>
 <div class="next" style="float: right;"><a href="regexp.reference.html">Регулярные выражения в деталях</a></div>
 <div class="up"><a href="reference.pcre.pattern.syntax.html">Описание синтаксиса Perl-совместимых регулярных выражений</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="pcre.pattern.syntax.differences" class="section">
  <h2 class="title">Отличия от Perl</h2>
  <p class="para">
   Разница описана относительно версии Perl 5.005.
   <ol class="orderedlist">
    <li class="listitem">
     <span class="simpara">
      По умолчанию пробельными символами являются все символы, 
      распознаваемые библиотечной  функцией  языка Си isspace().
      Это позволяет собрать PCRE библиотеку с произвольными
      символьными наборами. В стандартной поставке функция
      isspace() определяет как пробельные следующие символы: пробел, 
      разрыв страницы, начло строки, перевод каретки, горизонтальную и вертикальную табуляцию.
      Начиная с версии Perl 5.002, символ вертикальной табуляции \v
      не является пробельным и, соответственно, не соответствует классу символов \s.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      PCRE не позволяет использовать квантификаторы повторения в условных
      выражениях. Perl позволяет это делать, но получаемый результат может 
      существенно отличаться от ожидаемого.
      Например, (?!a){3} не означает, что три следующих символа будут не &#039;a&#039;.
      Он всего лишь трижды утверждает, что следующий символ не &#039;a&#039;.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Во время сопоставления подмаски, находящейся внутри отрицающего
      условного выражения, счетчик подмасок увеличивается, но сами значения,
      зафиксированные такой подмаской, не возвращаются (в результирующем массиве 
      по соответствующим смещениям находятся пустые строки).
      Perl устанавливает значения соответствующих числовых переменных исходя из
      предшествующей модмаски, найденной непосредственно перед тем, как отрицающее условие 
      не смогло быть сопоставлено (и таким образом выполнилось), но только в том случае,
      если условное выражение содержит только одну ветвь.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Несмотря на то, что символ, соответствующий ASCII-коду 0 (бинарный ноль), допускается
      в обрабатываемом тексте, он недопустим в шаблоне (так как передается в качестве аргумента Си-функции
      как нормальная строка, завершаемая нулевым символом). Cледующая служебная последовательность 
      &quot;\\x00&quot; может быть использована для представления бинарного ноля.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Следующие служебные последовательности, используемые в Perl, не поддерживаются:
      \l,  \u,  \L,  \U,  \E, \Q. Это связано с тем, что обработка указанных последовательностей
      производится внутренним Perl-механизмом обработки строк и не является частью механизма регулярных
      выражений.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Perl модификатор \G не поддерживается, так как он не входит в 
      рамки простого сопоставления шаблону.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Достаточно очевидно, что PCRE не поддерживает конструкции вида
      (?{code}).
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Теперь немного о чудаковатости в Perl 5.005_02, связанной с 
      фиксацией результата в случае, когда часть шаблона повторяется.
      Например, применяя шаблон /^(a(b)?)+$/  к строке &quot;aba&quot;, переменная $2 соответствует &#039;b&#039;.
      Но при применении шаблона  /^(aa(bb)?)+$/ к строке &quot;aabbaa&quot; переменная $2 оказывается неустановленной.
      А в случае, если шаблон изменить на /^(aa(b(b))?)+$/, переменные $2 и $3 окажутся установленными.
      В Perl 5.004, в обоих случаях переменная $2 будет содержать соответствующее значение, что соответствует PCRE.
      Если в будущем Perl изменит поведение в данной ситуации, PCRE также может измениться.
     </span>
    </li>
    <li class="listitem">
     <span class="simpara">
      Еще одна несовместимость, не находящая разумного объяснения.
      Шаблон /^(a)?(?(1)a|b)+$/ соответствует строке &#039;a&#039; в PERL, но не в PCRE.
      В то же время шаблон  /^(a)?a/ соответствует строке &#039;a&#039; и в Perl и в PCRE, 
      оставляя переменную $1 неустановленной.
     </span>
    </li>
    <li class="listitem">
     <p class="para">
      PCRE также предоставляет некоторое расширение возможностей Perl для
      обработки регулярных выражений:
      <ol class="orderedlist">
       <li class="listitem">
        <span class="simpara">
         Несмотря на то, что условное выражение, ссылающееся на предыдущие вхождения, 
         должно соответствовать строке фиксированной длины, каждая ветка такого выражения в отдельности может соответствовать строке
         произвольной длины (отличающейся от длины других веток).
         В то время как Perl 5.005 требует, чтобы все они имели одинаковую длину.
        </span>
       </li>
       <li class="listitem">
        <span class="simpara">
         В случае, если модификатор <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_DOLLAR_ENDONLY</a>  используется и  
         <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_MULTILINE</a>  не используется, специальный символ &#039;$&#039;
         соответствует исключительно концу обрабатываемых данных.
        </span>
       </li>
       <li class="listitem">
        <span class="simpara">
         В случае, если модификатор <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_EXTRA</a> используется, 
         обратный слеш, за которым следует символ, не имеющий специального значения, приводит к ошибке.
        </span>
       </li>
       <li class="listitem">
        <span class="simpara">
         Модификатор <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_UNGREEDY</a>
         инвертирует жадность квантификаторов, таким
         образом они по умолчанию не жадные. Но становятся жадными,
         если за ними следует символ &#039;?&#039;.
        </span>
       </li>
      </ol>
     </p>
    </li>
   </ol>
  </p>
 </div><hr /><div style="text-align: center;">
 <div class="prev" style="float: left;"><a href="reference.pcre.pattern.syntax.html">Описание синтаксиса Perl-совместимых регулярных выражений</a></div>
 <div class="next" style="float: right;"><a href="regexp.reference.html">Регулярные выражения в деталях</a></div>
 <div class="up"><a href="reference.pcre.pattern.syntax.html">Описание синтаксиса Perl-совместимых регулярных выражений</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
